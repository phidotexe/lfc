# NFA

# Non-deterministic Finite Automation

da *"LFC - A student approach"* 

Vediamo come **ricavare un NFA da un espressione regolare**.
Notiamo che il linguaggio denotato dalla *reg. exp.* √® lo stesso di quello riconosciuto dal'NFA

![Untitled%209.png](Untitled%209.png)

<aside>
üöß Dato un minDFA √® possibile ricavare l'espressione regolare, ma √® complesso e non lo vedremo

</aside>

### Definizione Formale NFA

Un NFA si definisce in maniera formale con una tupla:

$(S,  A, move_n, s_0,F)$  in cui:

$S:$ insieme di **stati**

$A:$ **alfabeto ‚Üí** insieme di simboli

$s_0:$ un **simbolo** $\in A$ **iniziale**

$F:$ insieme di **stati finali** $\sube S$

$move_n:$ funzione di transizione $S√ó(A \cup \{\epsilon\}) \to P(S)$

Dato uno stato ed un elemento dell'alfabeto $\cup \{\epsilon\}$, restituisce un insieme di stati. 
[Assegna un certo stato S ad una certa etichetta $(A \cup \{\epsilon\})$]

$P(S):$ Insieme delle parti $\xrightharpoondown{ovvero}$ sottoinsieme di stati

### Rappresentazione Grafica NFA

NFA ‚Üí Rappresentato da un **grafo** in cui:

**Nodi** ‚Üí **Stati** $\in S$

**Archi** ‚Üí $move_n$ ‚Üí gli archi sono etichettati da un simbolo dell'Alfabeto (œµ incluso)

Il **nodo** (**iniziale**) che rappresenta $S_0$ si evidenzia con una piccola freccia entrante

I nodi che rappresentano **stati** $\in F$ (**finali**) sono disegnati con un doppio cerchio

<aside>
‚ÄºÔ∏è **N.B.**
Non tutti i cammini portano necessariamente ad uno stato finale e uno o pi√π stati possono essere non raggiungibili

</aside>

<aside>
‚úÖ Un NFA pu√≤ rispondere YES o NO rilevando se l'espressione data in input appartiene al linguaggio, ovvero se raggiunge uno stato finale

</aside>